// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *CampusV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CampusV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("shortName")
		e.Str(s.ShortName)
	}
	{
		e.FieldStart("fullName")
		e.Str(s.FullName)
	}
}

var jsonFieldsNameOfCampusV1DTO = [3]string{
	0: "id",
	1: "shortName",
	2: "fullName",
}

// Decode decodes CampusV1DTO from json.
func (s *CampusV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CampusV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "shortName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ShortName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortName\"")
			}
		case "fullName":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FullName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fullName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CampusV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCampusV1DTO) {
					name = jsonFieldsNameOfCampusV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CampusV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CampusV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CampusesV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CampusesV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("campuses")
		e.ArrStart()
		for _, elem := range s.Campuses {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCampusesV1DTO = [1]string{
	0: "campuses",
}

// Decode decodes CampusesV1DTO from json.
func (s *CampusesV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CampusesV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "campuses":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Campuses = make([]CampusV1DTO, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CampusV1DTO
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Campuses = append(s.Campuses, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"campuses\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CampusesV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCampusesV1DTO) {
					name = jsonFieldsNameOfCampusesV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CampusesV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CampusesV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClusterMapV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClusterMapV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("clusterMap")
		e.ArrStart()
		for _, elem := range s.ClusterMap {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfClusterMapV1DTO = [1]string{
	0: "clusterMap",
}

// Decode decodes ClusterMapV1DTO from json.
func (s *ClusterMapV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClusterMapV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clusterMap":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.ClusterMap = make([]WorkplaceV1DTO, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WorkplaceV1DTO
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ClusterMap = append(s.ClusterMap, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterMap\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClusterMapV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfClusterMapV1DTO) {
					name = jsonFieldsNameOfClusterMapV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClusterMapV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClusterMapV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClusterV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClusterV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int64(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("capacity")
		e.Int32(s.Capacity)
	}
	{
		e.FieldStart("availableCapacity")
		e.Int32(s.AvailableCapacity)
	}
	{
		e.FieldStart("floor")
		e.Int32(s.Floor)
	}
}

var jsonFieldsNameOfClusterV1DTO = [5]string{
	0: "id",
	1: "name",
	2: "capacity",
	3: "availableCapacity",
	4: "floor",
}

// Decode decodes ClusterV1DTO from json.
func (s *ClusterV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClusterV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.ID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "capacity":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Capacity = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capacity\"")
			}
		case "availableCapacity":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.AvailableCapacity = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"availableCapacity\"")
			}
		case "floor":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.Floor = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"floor\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClusterV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfClusterV1DTO) {
					name = jsonFieldsNameOfClusterV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClusterV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClusterV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClustersV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClustersV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("clusters")
		e.ArrStart()
		for _, elem := range s.Clusters {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfClustersV1DTO = [1]string{
	0: "clusters",
}

// Decode decodes ClustersV1DTO from json.
func (s *ClustersV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClustersV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clusters":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Clusters = make([]ClusterV1DTO, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ClusterV1DTO
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Clusters = append(s.Clusters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClustersV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfClustersV1DTO) {
					name = jsonFieldsNameOfClustersV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClustersV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClustersV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CoalitionV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CoalitionV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("coalitionId")
		e.Int64(s.CoalitionId)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfCoalitionV1DTO = [2]string{
	0: "coalitionId",
	1: "name",
}

// Decode decodes CoalitionV1DTO from json.
func (s *CoalitionV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CoalitionV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "coalitionId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.CoalitionId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"coalitionId\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CoalitionV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCoalitionV1DTO) {
					name = jsonFieldsNameOfCoalitionV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CoalitionV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CoalitionV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CoalitionsV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CoalitionsV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("coalitions")
		e.ArrStart()
		for _, elem := range s.Coalitions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCoalitionsV1DTO = [1]string{
	0: "coalitions",
}

// Decode decodes CoalitionsV1DTO from json.
func (s *CoalitionsV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CoalitionsV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "coalitions":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Coalitions = make([]CoalitionV1DTO, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CoalitionV1DTO
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Coalitions = append(s.Coalitions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"coalitions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CoalitionsV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCoalitionsV1DTO) {
					name = jsonFieldsNameOfCoalitionsV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CoalitionsV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CoalitionsV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConditionRuleGroupV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConditionRuleGroupV1DTO) encodeFields(e *jx.Encoder) {
	{
		if s.LogicalOperator.Set {
			e.FieldStart("logicalOperator")
			s.LogicalOperator.Encode(e)
		}
	}
	{
		e.FieldStart("rulesInGroup")
		e.ArrStart()
		for _, elem := range s.RulesInGroup {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfConditionRuleGroupV1DTO = [2]string{
	0: "logicalOperator",
	1: "rulesInGroup",
}

// Decode decodes ConditionRuleGroupV1DTO from json.
func (s *ConditionRuleGroupV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConditionRuleGroupV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "logicalOperator":
			if err := func() error {
				s.LogicalOperator.Reset()
				if err := s.LogicalOperator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logicalOperator\"")
			}
		case "rulesInGroup":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.RulesInGroup = make([]ConditionRuleV1DTO, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConditionRuleV1DTO
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RulesInGroup = append(s.RulesInGroup, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rulesInGroup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConditionRuleGroupV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConditionRuleGroupV1DTO) {
					name = jsonFieldsNameOfConditionRuleGroupV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConditionRuleGroupV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConditionRuleGroupV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConditionRuleGroupV1DTOLogicalOperator as json.
func (s ConditionRuleGroupV1DTOLogicalOperator) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConditionRuleGroupV1DTOLogicalOperator from json.
func (s *ConditionRuleGroupV1DTOLogicalOperator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConditionRuleGroupV1DTOLogicalOperator to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConditionRuleGroupV1DTOLogicalOperator(v) {
	case ConditionRuleGroupV1DTOLogicalOperatorOR:
		*s = ConditionRuleGroupV1DTOLogicalOperatorOR
	case ConditionRuleGroupV1DTOLogicalOperatorAND:
		*s = ConditionRuleGroupV1DTOLogicalOperatorAND
	default:
		*s = ConditionRuleGroupV1DTOLogicalOperator(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConditionRuleGroupV1DTOLogicalOperator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConditionRuleGroupV1DTOLogicalOperator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConditionRuleV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConditionRuleV1DTO) encodeFields(e *jx.Encoder) {
	{
		if s.LogicalOperator.Set {
			e.FieldStart("logicalOperator")
			s.LogicalOperator.Encode(e)
		}
	}
	{
		e.FieldStart("value")
		s.Value.Encode(e)
	}
}

var jsonFieldsNameOfConditionRuleV1DTO = [2]string{
	0: "logicalOperator",
	1: "value",
}

// Decode decodes ConditionRuleV1DTO from json.
func (s *ConditionRuleV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConditionRuleV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "logicalOperator":
			if err := func() error {
				s.LogicalOperator.Reset()
				if err := s.LogicalOperator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logicalOperator\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConditionRuleV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConditionRuleV1DTO) {
					name = jsonFieldsNameOfConditionRuleV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConditionRuleV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConditionRuleV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConditionRuleV1DTOLogicalOperator as json.
func (s ConditionRuleV1DTOLogicalOperator) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConditionRuleV1DTOLogicalOperator from json.
func (s *ConditionRuleV1DTOLogicalOperator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConditionRuleV1DTOLogicalOperator to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConditionRuleV1DTOLogicalOperator(v) {
	case ConditionRuleV1DTOLogicalOperatorOR:
		*s = ConditionRuleV1DTOLogicalOperatorOR
	case ConditionRuleV1DTOLogicalOperatorAND:
		*s = ConditionRuleV1DTOLogicalOperatorAND
	default:
		*s = ConditionRuleV1DTOLogicalOperator(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConditionRuleV1DTOLogicalOperator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConditionRuleV1DTOLogicalOperator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConditionRuleValueV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConditionRuleValueV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("fieldId")
		e.Int64(s.FieldId)
	}
	{
		e.FieldStart("fieldName")
		e.Str(s.FieldName)
	}
	{
		e.FieldStart("subFieldKey")
		e.Str(s.SubFieldKey)
	}
	{
		e.FieldStart("subFieldValue")
		e.Str(s.SubFieldValue)
	}
	{
		e.FieldStart("operator")
		e.Str(s.Operator)
	}
	{
		e.FieldStart("value")
		e.ArrStart()
		for _, elem := range s.Value {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfConditionRuleValueV1DTO = [6]string{
	0: "fieldId",
	1: "fieldName",
	2: "subFieldKey",
	3: "subFieldValue",
	4: "operator",
	5: "value",
}

// Decode decodes ConditionRuleValueV1DTO from json.
func (s *ConditionRuleValueV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConditionRuleValueV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fieldId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.FieldId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fieldId\"")
			}
		case "fieldName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FieldName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fieldName\"")
			}
		case "subFieldKey":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.SubFieldKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subFieldKey\"")
			}
		case "subFieldValue":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.SubFieldValue = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subFieldValue\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Operator = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Value = make([]ConditionValueValueV1DTO, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConditionValueValueV1DTO
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Value = append(s.Value, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConditionRuleValueV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConditionRuleValueV1DTO) {
					name = jsonFieldsNameOfConditionRuleValueV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConditionRuleValueV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConditionRuleValueV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConditionValueValueV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConditionValueValueV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfConditionValueValueV1DTO = [2]string{
	0: "key",
	1: "value",
}

// Decode decodes ConditionValueValueV1DTO from json.
func (s *ConditionValueValueV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConditionValueValueV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConditionValueValueV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConditionValueValueV1DTO) {
					name = jsonFieldsNameOfConditionValueValueV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConditionValueValueV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConditionValueValueV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CourseV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CourseV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("courseId")
		e.Int64(s.CourseId)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("durationHours")
		e.Int32(s.DurationHours)
	}
	{
		e.FieldStart("xp")
		e.Int32(s.Xp)
	}
	{
		if s.StartConditions != nil {
			e.FieldStart("startConditions")
			e.ArrStart()
			for _, elem := range s.StartConditions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCourseV1DTO = [6]string{
	0: "courseId",
	1: "title",
	2: "description",
	3: "durationHours",
	4: "xp",
	5: "startConditions",
}

// Decode decodes CourseV1DTO from json.
func (s *CourseV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CourseV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "courseId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.CourseId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"courseId\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "durationHours":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.DurationHours = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"durationHours\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.Xp = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "startConditions":
			if err := func() error {
				s.StartConditions = make([]ConditionRuleGroupV1DTO, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConditionRuleGroupV1DTO
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.StartConditions = append(s.StartConditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startConditions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CourseV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCourseV1DTO) {
					name = jsonFieldsNameOfCourseV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CourseV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CourseV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorResponseDTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorResponseDTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Int32(s.Status)
	}
	{
		e.FieldStart("exceptionUUID")
		e.Str(s.ExceptionUUID)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfErrorResponseDTO = [4]string{
	0: "status",
	1: "exceptionUUID",
	2: "code",
	3: "message",
}

// Decode decodes ErrorResponseDTO from json.
func (s *ErrorResponseDTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorResponseDTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Status = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "exceptionUUID":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ExceptionUUID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exceptionUUID\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorResponseDTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfErrorResponseDTO) {
					name = jsonFieldsNameOfErrorResponseDTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorResponseDTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorResponseDTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int64(s.ID)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("location")
		e.Str(s.Location)
	}
	{
		e.FieldStart("startDateTime")
		json.EncodeDateTime(e, s.StartDateTime)
	}
	{
		e.FieldStart("endDateTime")
		json.EncodeDateTime(e, s.EndDateTime)
	}
	{
		e.FieldStart("organizers")
		e.ArrStart()
		for _, elem := range s.Organizers {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("capacity")
		e.Int32(s.Capacity)
	}
	{
		e.FieldStart("registerCount")
		e.Int32(s.RegisterCount)
	}
}

var jsonFieldsNameOfEventV1DTO = [10]string{
	0: "id",
	1: "type",
	2: "name",
	3: "description",
	4: "location",
	5: "startDateTime",
	6: "endDateTime",
	7: "organizers",
	8: "capacity",
	9: "registerCount",
}

// Decode decodes EventV1DTO from json.
func (s *EventV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventV1DTO to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.ID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "location":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Location = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "startDateTime":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartDateTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startDateTime\"")
			}
		case "endDateTime":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.EndDateTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endDateTime\"")
			}
		case "organizers":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.Organizers = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Organizers = append(s.Organizers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizers\"")
			}
		case "capacity":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Capacity = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capacity\"")
			}
		case "registerCount":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.RegisterCount = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"registerCount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11110111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEventV1DTO) {
					name = jsonFieldsNameOfEventV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventsV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventsV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("events")
		e.ArrStart()
		for _, elem := range s.Events {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfEventsV1DTO = [1]string{
	0: "events",
}

// Decode decodes EventsV1DTO from json.
func (s *EventsV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventsV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "events":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Events = make([]EventV1DTO, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EventV1DTO
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventsV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEventsV1DTO) {
					name = jsonFieldsNameOfEventsV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventsV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventsV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBadgesByLoginBadRequest as json.
func (s *GetBadgesByLoginBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBadgesByLoginBadRequest from json.
func (s *GetBadgesByLoginBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBadgesByLoginBadRequest to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBadgesByLoginBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBadgesByLoginBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBadgesByLoginBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBadgesByLoginForbidden as json.
func (s *GetBadgesByLoginForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBadgesByLoginForbidden from json.
func (s *GetBadgesByLoginForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBadgesByLoginForbidden to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBadgesByLoginForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBadgesByLoginForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBadgesByLoginForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBadgesByLoginInternalServerError as json.
func (s *GetBadgesByLoginInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBadgesByLoginInternalServerError from json.
func (s *GetBadgesByLoginInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBadgesByLoginInternalServerError to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBadgesByLoginInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBadgesByLoginInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBadgesByLoginInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBadgesByLoginNotFound as json.
func (s *GetBadgesByLoginNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetBadgesByLoginNotFound from json.
func (s *GetBadgesByLoginNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBadgesByLoginNotFound to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBadgesByLoginNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBadgesByLoginNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBadgesByLoginNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCampusesBadRequest as json.
func (s *GetCampusesBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCampusesBadRequest from json.
func (s *GetCampusesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCampusesBadRequest to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCampusesBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCampusesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCampusesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCampusesInternalServerError as json.
func (s *GetCampusesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCampusesInternalServerError from json.
func (s *GetCampusesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCampusesInternalServerError to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCampusesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCampusesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCampusesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClustersByCampusBadRequest as json.
func (s *GetClustersByCampusBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClustersByCampusBadRequest from json.
func (s *GetClustersByCampusBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClustersByCampusBadRequest to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClustersByCampusBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClustersByCampusBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClustersByCampusBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClustersByCampusForbidden as json.
func (s *GetClustersByCampusForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClustersByCampusForbidden from json.
func (s *GetClustersByCampusForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClustersByCampusForbidden to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClustersByCampusForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClustersByCampusForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClustersByCampusForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClustersByCampusInternalServerError as json.
func (s *GetClustersByCampusInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClustersByCampusInternalServerError from json.
func (s *GetClustersByCampusInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClustersByCampusInternalServerError to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClustersByCampusInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClustersByCampusInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClustersByCampusInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClustersByCampusNotFound as json.
func (s *GetClustersByCampusNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClustersByCampusNotFound from json.
func (s *GetClustersByCampusNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClustersByCampusNotFound to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClustersByCampusNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClustersByCampusNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClustersByCampusNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCoalitionByLoginBadRequest as json.
func (s *GetCoalitionByLoginBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCoalitionByLoginBadRequest from json.
func (s *GetCoalitionByLoginBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCoalitionByLoginBadRequest to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCoalitionByLoginBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCoalitionByLoginBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCoalitionByLoginBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCoalitionByLoginForbidden as json.
func (s *GetCoalitionByLoginForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCoalitionByLoginForbidden from json.
func (s *GetCoalitionByLoginForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCoalitionByLoginForbidden to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCoalitionByLoginForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCoalitionByLoginForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCoalitionByLoginForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCoalitionByLoginInternalServerError as json.
func (s *GetCoalitionByLoginInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCoalitionByLoginInternalServerError from json.
func (s *GetCoalitionByLoginInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCoalitionByLoginInternalServerError to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCoalitionByLoginInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCoalitionByLoginInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCoalitionByLoginInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCoalitionByLoginNotFound as json.
func (s *GetCoalitionByLoginNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCoalitionByLoginNotFound from json.
func (s *GetCoalitionByLoginNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCoalitionByLoginNotFound to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCoalitionByLoginNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCoalitionByLoginNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCoalitionByLoginNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCoalitionsByCampusBadRequest as json.
func (s *GetCoalitionsByCampusBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCoalitionsByCampusBadRequest from json.
func (s *GetCoalitionsByCampusBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCoalitionsByCampusBadRequest to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCoalitionsByCampusBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCoalitionsByCampusBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCoalitionsByCampusBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCoalitionsByCampusForbidden as json.
func (s *GetCoalitionsByCampusForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCoalitionsByCampusForbidden from json.
func (s *GetCoalitionsByCampusForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCoalitionsByCampusForbidden to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCoalitionsByCampusForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCoalitionsByCampusForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCoalitionsByCampusForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCoalitionsByCampusInternalServerError as json.
func (s *GetCoalitionsByCampusInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCoalitionsByCampusInternalServerError from json.
func (s *GetCoalitionsByCampusInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCoalitionsByCampusInternalServerError to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCoalitionsByCampusInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCoalitionsByCampusInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCoalitionsByCampusInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCoalitionsByCampusNotFound as json.
func (s *GetCoalitionsByCampusNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCoalitionsByCampusNotFound from json.
func (s *GetCoalitionsByCampusNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCoalitionsByCampusNotFound to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCoalitionsByCampusNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCoalitionsByCampusNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCoalitionsByCampusNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCourseByCourseIdBadRequest as json.
func (s *GetCourseByCourseIdBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCourseByCourseIdBadRequest from json.
func (s *GetCourseByCourseIdBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCourseByCourseIdBadRequest to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCourseByCourseIdBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCourseByCourseIdBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCourseByCourseIdBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCourseByCourseIdForbidden as json.
func (s *GetCourseByCourseIdForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCourseByCourseIdForbidden from json.
func (s *GetCourseByCourseIdForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCourseByCourseIdForbidden to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCourseByCourseIdForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCourseByCourseIdForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCourseByCourseIdForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCourseByCourseIdInternalServerError as json.
func (s *GetCourseByCourseIdInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCourseByCourseIdInternalServerError from json.
func (s *GetCourseByCourseIdInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCourseByCourseIdInternalServerError to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCourseByCourseIdInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCourseByCourseIdInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCourseByCourseIdInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCourseByCourseIdNotFound as json.
func (s *GetCourseByCourseIdNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCourseByCourseIdNotFound from json.
func (s *GetCourseByCourseIdNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCourseByCourseIdNotFound to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCourseByCourseIdNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCourseByCourseIdNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCourseByCourseIdNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetEventsBadRequest as json.
func (s *GetEventsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetEventsBadRequest from json.
func (s *GetEventsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetEventsBadRequest to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetEventsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetEventsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetEventsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetEventsInternalServerError as json.
func (s *GetEventsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetEventsInternalServerError from json.
func (s *GetEventsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetEventsInternalServerError to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetEventsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetEventsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetEventsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetGraphBadRequest as json.
func (s *GetGraphBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetGraphBadRequest from json.
func (s *GetGraphBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetGraphBadRequest to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetGraphBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetGraphBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetGraphBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetGraphInternalServerError as json.
func (s *GetGraphInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetGraphInternalServerError from json.
func (s *GetGraphInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetGraphInternalServerError to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetGraphInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetGraphInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetGraphInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetLogWeeklyAvgHoursByLoginAndDateBadRequest as json.
func (s *GetLogWeeklyAvgHoursByLoginAndDateBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetLogWeeklyAvgHoursByLoginAndDateBadRequest from json.
func (s *GetLogWeeklyAvgHoursByLoginAndDateBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetLogWeeklyAvgHoursByLoginAndDateBadRequest to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetLogWeeklyAvgHoursByLoginAndDateBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetLogWeeklyAvgHoursByLoginAndDateBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetLogWeeklyAvgHoursByLoginAndDateBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetLogWeeklyAvgHoursByLoginAndDateForbidden as json.
func (s *GetLogWeeklyAvgHoursByLoginAndDateForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetLogWeeklyAvgHoursByLoginAndDateForbidden from json.
func (s *GetLogWeeklyAvgHoursByLoginAndDateForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetLogWeeklyAvgHoursByLoginAndDateForbidden to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetLogWeeklyAvgHoursByLoginAndDateForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetLogWeeklyAvgHoursByLoginAndDateForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetLogWeeklyAvgHoursByLoginAndDateForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetLogWeeklyAvgHoursByLoginAndDateInternalServerError as json.
func (s *GetLogWeeklyAvgHoursByLoginAndDateInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetLogWeeklyAvgHoursByLoginAndDateInternalServerError from json.
func (s *GetLogWeeklyAvgHoursByLoginAndDateInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetLogWeeklyAvgHoursByLoginAndDateInternalServerError to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetLogWeeklyAvgHoursByLoginAndDateInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetLogWeeklyAvgHoursByLoginAndDateInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetLogWeeklyAvgHoursByLoginAndDateInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetLogWeeklyAvgHoursByLoginAndDateNotFound as json.
func (s *GetLogWeeklyAvgHoursByLoginAndDateNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetLogWeeklyAvgHoursByLoginAndDateNotFound from json.
func (s *GetLogWeeklyAvgHoursByLoginAndDateNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetLogWeeklyAvgHoursByLoginAndDateNotFound to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetLogWeeklyAvgHoursByLoginAndDateNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetLogWeeklyAvgHoursByLoginAndDateNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetLogWeeklyAvgHoursByLoginAndDateNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetLogWeeklyAvgHoursByLoginAndDateOKApplicationJSON as json.
func (s GetLogWeeklyAvgHoursByLoginAndDateOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := float64(s)

	e.Float64(unwrapped)
}

// Decode decodes GetLogWeeklyAvgHoursByLoginAndDateOKApplicationJSON from json.
func (s *GetLogWeeklyAvgHoursByLoginAndDateOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetLogWeeklyAvgHoursByLoginAndDateOKApplicationJSON to nil")
	}
	var unwrapped float64
	if err := func() error {
		v, err := d.Float64()
		unwrapped = float64(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetLogWeeklyAvgHoursByLoginAndDateOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetLogWeeklyAvgHoursByLoginAndDateOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetLogWeeklyAvgHoursByLoginAndDateOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetLoginsByProjectIdBadRequest as json.
func (s *GetLoginsByProjectIdBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetLoginsByProjectIdBadRequest from json.
func (s *GetLoginsByProjectIdBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetLoginsByProjectIdBadRequest to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetLoginsByProjectIdBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetLoginsByProjectIdBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetLoginsByProjectIdBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetLoginsByProjectIdForbidden as json.
func (s *GetLoginsByProjectIdForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetLoginsByProjectIdForbidden from json.
func (s *GetLoginsByProjectIdForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetLoginsByProjectIdForbidden to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetLoginsByProjectIdForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetLoginsByProjectIdForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetLoginsByProjectIdForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetLoginsByProjectIdInternalServerError as json.
func (s *GetLoginsByProjectIdInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetLoginsByProjectIdInternalServerError from json.
func (s *GetLoginsByProjectIdInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetLoginsByProjectIdInternalServerError to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetLoginsByProjectIdInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetLoginsByProjectIdInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetLoginsByProjectIdInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetLoginsByProjectIdNotFound as json.
func (s *GetLoginsByProjectIdNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetLoginsByProjectIdNotFound from json.
func (s *GetLoginsByProjectIdNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetLoginsByProjectIdNotFound to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetLoginsByProjectIdNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetLoginsByProjectIdNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetLoginsByProjectIdNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantByLoginBadRequest as json.
func (s *GetParticipantByLoginBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantByLoginBadRequest from json.
func (s *GetParticipantByLoginBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantByLoginBadRequest to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantByLoginBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantByLoginBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantByLoginBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantByLoginForbidden as json.
func (s *GetParticipantByLoginForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantByLoginForbidden from json.
func (s *GetParticipantByLoginForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantByLoginForbidden to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantByLoginForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantByLoginForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantByLoginForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantByLoginInternalServerError as json.
func (s *GetParticipantByLoginInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantByLoginInternalServerError from json.
func (s *GetParticipantByLoginInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantByLoginInternalServerError to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantByLoginInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantByLoginInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantByLoginInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantByLoginNotFound as json.
func (s *GetParticipantByLoginNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantByLoginNotFound from json.
func (s *GetParticipantByLoginNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantByLoginNotFound to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantByLoginNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantByLoginNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantByLoginNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantCourseByLoginAndCourseIdBadRequest as json.
func (s *GetParticipantCourseByLoginAndCourseIdBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantCourseByLoginAndCourseIdBadRequest from json.
func (s *GetParticipantCourseByLoginAndCourseIdBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantCourseByLoginAndCourseIdBadRequest to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantCourseByLoginAndCourseIdBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantCourseByLoginAndCourseIdBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantCourseByLoginAndCourseIdBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantCourseByLoginAndCourseIdForbidden as json.
func (s *GetParticipantCourseByLoginAndCourseIdForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantCourseByLoginAndCourseIdForbidden from json.
func (s *GetParticipantCourseByLoginAndCourseIdForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantCourseByLoginAndCourseIdForbidden to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantCourseByLoginAndCourseIdForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantCourseByLoginAndCourseIdForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantCourseByLoginAndCourseIdForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantCourseByLoginAndCourseIdInternalServerError as json.
func (s *GetParticipantCourseByLoginAndCourseIdInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantCourseByLoginAndCourseIdInternalServerError from json.
func (s *GetParticipantCourseByLoginAndCourseIdInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantCourseByLoginAndCourseIdInternalServerError to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantCourseByLoginAndCourseIdInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantCourseByLoginAndCourseIdInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantCourseByLoginAndCourseIdInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantCourseByLoginAndCourseIdNotFound as json.
func (s *GetParticipantCourseByLoginAndCourseIdNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantCourseByLoginAndCourseIdNotFound from json.
func (s *GetParticipantCourseByLoginAndCourseIdNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantCourseByLoginAndCourseIdNotFound to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantCourseByLoginAndCourseIdNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantCourseByLoginAndCourseIdNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantCourseByLoginAndCourseIdNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantCoursesByLoginBadRequest as json.
func (s *GetParticipantCoursesByLoginBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantCoursesByLoginBadRequest from json.
func (s *GetParticipantCoursesByLoginBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantCoursesByLoginBadRequest to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantCoursesByLoginBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantCoursesByLoginBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantCoursesByLoginBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantCoursesByLoginForbidden as json.
func (s *GetParticipantCoursesByLoginForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantCoursesByLoginForbidden from json.
func (s *GetParticipantCoursesByLoginForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantCoursesByLoginForbidden to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantCoursesByLoginForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantCoursesByLoginForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantCoursesByLoginForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantCoursesByLoginInternalServerError as json.
func (s *GetParticipantCoursesByLoginInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantCoursesByLoginInternalServerError from json.
func (s *GetParticipantCoursesByLoginInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantCoursesByLoginInternalServerError to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantCoursesByLoginInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantCoursesByLoginInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantCoursesByLoginInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantCoursesByLoginNotFound as json.
func (s *GetParticipantCoursesByLoginNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantCoursesByLoginNotFound from json.
func (s *GetParticipantCoursesByLoginNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantCoursesByLoginNotFound to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantCoursesByLoginNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantCoursesByLoginNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantCoursesByLoginNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantFeedbackByLoginBadRequest as json.
func (s *GetParticipantFeedbackByLoginBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantFeedbackByLoginBadRequest from json.
func (s *GetParticipantFeedbackByLoginBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantFeedbackByLoginBadRequest to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantFeedbackByLoginBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantFeedbackByLoginBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantFeedbackByLoginBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantFeedbackByLoginForbidden as json.
func (s *GetParticipantFeedbackByLoginForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantFeedbackByLoginForbidden from json.
func (s *GetParticipantFeedbackByLoginForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantFeedbackByLoginForbidden to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantFeedbackByLoginForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantFeedbackByLoginForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantFeedbackByLoginForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantFeedbackByLoginInternalServerError as json.
func (s *GetParticipantFeedbackByLoginInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantFeedbackByLoginInternalServerError from json.
func (s *GetParticipantFeedbackByLoginInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantFeedbackByLoginInternalServerError to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantFeedbackByLoginInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantFeedbackByLoginInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantFeedbackByLoginInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantFeedbackByLoginNotFound as json.
func (s *GetParticipantFeedbackByLoginNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantFeedbackByLoginNotFound from json.
func (s *GetParticipantFeedbackByLoginNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantFeedbackByLoginNotFound to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantFeedbackByLoginNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantFeedbackByLoginNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantFeedbackByLoginNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantProjectByLoginAndProjectIdBadRequest as json.
func (s *GetParticipantProjectByLoginAndProjectIdBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantProjectByLoginAndProjectIdBadRequest from json.
func (s *GetParticipantProjectByLoginAndProjectIdBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantProjectByLoginAndProjectIdBadRequest to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantProjectByLoginAndProjectIdBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantProjectByLoginAndProjectIdBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantProjectByLoginAndProjectIdBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantProjectByLoginAndProjectIdForbidden as json.
func (s *GetParticipantProjectByLoginAndProjectIdForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantProjectByLoginAndProjectIdForbidden from json.
func (s *GetParticipantProjectByLoginAndProjectIdForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantProjectByLoginAndProjectIdForbidden to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantProjectByLoginAndProjectIdForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantProjectByLoginAndProjectIdForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantProjectByLoginAndProjectIdForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantProjectByLoginAndProjectIdInternalServerError as json.
func (s *GetParticipantProjectByLoginAndProjectIdInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantProjectByLoginAndProjectIdInternalServerError from json.
func (s *GetParticipantProjectByLoginAndProjectIdInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantProjectByLoginAndProjectIdInternalServerError to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantProjectByLoginAndProjectIdInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantProjectByLoginAndProjectIdInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantProjectByLoginAndProjectIdInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantProjectByLoginAndProjectIdNotFound as json.
func (s *GetParticipantProjectByLoginAndProjectIdNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantProjectByLoginAndProjectIdNotFound from json.
func (s *GetParticipantProjectByLoginAndProjectIdNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantProjectByLoginAndProjectIdNotFound to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantProjectByLoginAndProjectIdNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantProjectByLoginAndProjectIdNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantProjectByLoginAndProjectIdNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantProjectsByLoginBadRequest as json.
func (s *GetParticipantProjectsByLoginBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantProjectsByLoginBadRequest from json.
func (s *GetParticipantProjectsByLoginBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantProjectsByLoginBadRequest to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantProjectsByLoginBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantProjectsByLoginBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantProjectsByLoginBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantProjectsByLoginForbidden as json.
func (s *GetParticipantProjectsByLoginForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantProjectsByLoginForbidden from json.
func (s *GetParticipantProjectsByLoginForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantProjectsByLoginForbidden to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantProjectsByLoginForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantProjectsByLoginForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantProjectsByLoginForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantProjectsByLoginInternalServerError as json.
func (s *GetParticipantProjectsByLoginInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantProjectsByLoginInternalServerError from json.
func (s *GetParticipantProjectsByLoginInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantProjectsByLoginInternalServerError to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantProjectsByLoginInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantProjectsByLoginInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantProjectsByLoginInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantProjectsByLoginNotFound as json.
func (s *GetParticipantProjectsByLoginNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantProjectsByLoginNotFound from json.
func (s *GetParticipantProjectsByLoginNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantProjectsByLoginNotFound to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantProjectsByLoginNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantProjectsByLoginNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantProjectsByLoginNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantWorkstationByLoginBadRequest as json.
func (s *GetParticipantWorkstationByLoginBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantWorkstationByLoginBadRequest from json.
func (s *GetParticipantWorkstationByLoginBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantWorkstationByLoginBadRequest to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantWorkstationByLoginBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantWorkstationByLoginBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantWorkstationByLoginBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantWorkstationByLoginForbidden as json.
func (s *GetParticipantWorkstationByLoginForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantWorkstationByLoginForbidden from json.
func (s *GetParticipantWorkstationByLoginForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantWorkstationByLoginForbidden to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantWorkstationByLoginForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantWorkstationByLoginForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantWorkstationByLoginForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantWorkstationByLoginInternalServerError as json.
func (s *GetParticipantWorkstationByLoginInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantWorkstationByLoginInternalServerError from json.
func (s *GetParticipantWorkstationByLoginInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantWorkstationByLoginInternalServerError to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantWorkstationByLoginInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantWorkstationByLoginInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantWorkstationByLoginInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantWorkstationByLoginNotFound as json.
func (s *GetParticipantWorkstationByLoginNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantWorkstationByLoginNotFound from json.
func (s *GetParticipantWorkstationByLoginNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantWorkstationByLoginNotFound to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantWorkstationByLoginNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantWorkstationByLoginNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantWorkstationByLoginNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantsByCampusIdBadRequest as json.
func (s *GetParticipantsByCampusIdBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantsByCampusIdBadRequest from json.
func (s *GetParticipantsByCampusIdBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantsByCampusIdBadRequest to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantsByCampusIdBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantsByCampusIdBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantsByCampusIdBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantsByCampusIdForbidden as json.
func (s *GetParticipantsByCampusIdForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantsByCampusIdForbidden from json.
func (s *GetParticipantsByCampusIdForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantsByCampusIdForbidden to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantsByCampusIdForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantsByCampusIdForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantsByCampusIdForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantsByCampusIdInternalServerError as json.
func (s *GetParticipantsByCampusIdInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantsByCampusIdInternalServerError from json.
func (s *GetParticipantsByCampusIdInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantsByCampusIdInternalServerError to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantsByCampusIdInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantsByCampusIdInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantsByCampusIdInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantsByCampusIdNotFound as json.
func (s *GetParticipantsByCampusIdNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantsByCampusIdNotFound from json.
func (s *GetParticipantsByCampusIdNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantsByCampusIdNotFound to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantsByCampusIdNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantsByCampusIdNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantsByCampusIdNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantsByCoalitionId1BadRequest as json.
func (s *GetParticipantsByCoalitionId1BadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantsByCoalitionId1BadRequest from json.
func (s *GetParticipantsByCoalitionId1BadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantsByCoalitionId1BadRequest to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantsByCoalitionId1BadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantsByCoalitionId1BadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantsByCoalitionId1BadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantsByCoalitionId1InternalServerError as json.
func (s *GetParticipantsByCoalitionId1InternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantsByCoalitionId1InternalServerError from json.
func (s *GetParticipantsByCoalitionId1InternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantsByCoalitionId1InternalServerError to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantsByCoalitionId1InternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantsByCoalitionId1InternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantsByCoalitionId1InternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantsByCoalitionIdBadRequest as json.
func (s *GetParticipantsByCoalitionIdBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantsByCoalitionIdBadRequest from json.
func (s *GetParticipantsByCoalitionIdBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantsByCoalitionIdBadRequest to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantsByCoalitionIdBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantsByCoalitionIdBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantsByCoalitionIdBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetParticipantsByCoalitionIdInternalServerError as json.
func (s *GetParticipantsByCoalitionIdInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetParticipantsByCoalitionIdInternalServerError from json.
func (s *GetParticipantsByCoalitionIdInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetParticipantsByCoalitionIdInternalServerError to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetParticipantsByCoalitionIdInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetParticipantsByCoalitionIdInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetParticipantsByCoalitionIdInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPointsByLoginBadRequest as json.
func (s *GetPointsByLoginBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPointsByLoginBadRequest from json.
func (s *GetPointsByLoginBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPointsByLoginBadRequest to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPointsByLoginBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPointsByLoginBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPointsByLoginBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPointsByLoginForbidden as json.
func (s *GetPointsByLoginForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPointsByLoginForbidden from json.
func (s *GetPointsByLoginForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPointsByLoginForbidden to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPointsByLoginForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPointsByLoginForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPointsByLoginForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPointsByLoginInternalServerError as json.
func (s *GetPointsByLoginInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPointsByLoginInternalServerError from json.
func (s *GetPointsByLoginInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPointsByLoginInternalServerError to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPointsByLoginInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPointsByLoginInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPointsByLoginInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPointsByLoginNotFound as json.
func (s *GetPointsByLoginNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetPointsByLoginNotFound from json.
func (s *GetPointsByLoginNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPointsByLoginNotFound to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetPointsByLoginNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPointsByLoginNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPointsByLoginNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetProjectByProjectIdBadRequest as json.
func (s *GetProjectByProjectIdBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetProjectByProjectIdBadRequest from json.
func (s *GetProjectByProjectIdBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetProjectByProjectIdBadRequest to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetProjectByProjectIdBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetProjectByProjectIdBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetProjectByProjectIdBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetProjectByProjectIdForbidden as json.
func (s *GetProjectByProjectIdForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetProjectByProjectIdForbidden from json.
func (s *GetProjectByProjectIdForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetProjectByProjectIdForbidden to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetProjectByProjectIdForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetProjectByProjectIdForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetProjectByProjectIdForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetProjectByProjectIdInternalServerError as json.
func (s *GetProjectByProjectIdInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetProjectByProjectIdInternalServerError from json.
func (s *GetProjectByProjectIdInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetProjectByProjectIdInternalServerError to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetProjectByProjectIdInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetProjectByProjectIdInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetProjectByProjectIdInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetProjectByProjectIdNotFound as json.
func (s *GetProjectByProjectIdNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetProjectByProjectIdNotFound from json.
func (s *GetProjectByProjectIdNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetProjectByProjectIdNotFound to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetProjectByProjectIdNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetProjectByProjectIdNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetProjectByProjectIdNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSalesBadRequest as json.
func (s *GetSalesBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSalesBadRequest from json.
func (s *GetSalesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSalesBadRequest to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSalesBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSalesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSalesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSalesInternalServerError as json.
func (s *GetSalesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSalesInternalServerError from json.
func (s *GetSalesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSalesInternalServerError to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSalesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSalesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSalesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSoftSkillByLoginBadRequest as json.
func (s *GetSoftSkillByLoginBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSoftSkillByLoginBadRequest from json.
func (s *GetSoftSkillByLoginBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSoftSkillByLoginBadRequest to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSoftSkillByLoginBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSoftSkillByLoginBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSoftSkillByLoginBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSoftSkillByLoginForbidden as json.
func (s *GetSoftSkillByLoginForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSoftSkillByLoginForbidden from json.
func (s *GetSoftSkillByLoginForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSoftSkillByLoginForbidden to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSoftSkillByLoginForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSoftSkillByLoginForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSoftSkillByLoginForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSoftSkillByLoginInternalServerError as json.
func (s *GetSoftSkillByLoginInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSoftSkillByLoginInternalServerError from json.
func (s *GetSoftSkillByLoginInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSoftSkillByLoginInternalServerError to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSoftSkillByLoginInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSoftSkillByLoginInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSoftSkillByLoginInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSoftSkillByLoginNotFound as json.
func (s *GetSoftSkillByLoginNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSoftSkillByLoginNotFound from json.
func (s *GetSoftSkillByLoginNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSoftSkillByLoginNotFound to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSoftSkillByLoginNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSoftSkillByLoginNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSoftSkillByLoginNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetXpHistoryByLoginBadRequest as json.
func (s *GetXpHistoryByLoginBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetXpHistoryByLoginBadRequest from json.
func (s *GetXpHistoryByLoginBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetXpHistoryByLoginBadRequest to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetXpHistoryByLoginBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetXpHistoryByLoginBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetXpHistoryByLoginBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetXpHistoryByLoginForbidden as json.
func (s *GetXpHistoryByLoginForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetXpHistoryByLoginForbidden from json.
func (s *GetXpHistoryByLoginForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetXpHistoryByLoginForbidden to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetXpHistoryByLoginForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetXpHistoryByLoginForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetXpHistoryByLoginForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetXpHistoryByLoginInternalServerError as json.
func (s *GetXpHistoryByLoginInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetXpHistoryByLoginInternalServerError from json.
func (s *GetXpHistoryByLoginInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetXpHistoryByLoginInternalServerError to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetXpHistoryByLoginInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetXpHistoryByLoginInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetXpHistoryByLoginInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetXpHistoryByLoginNotFound as json.
func (s *GetXpHistoryByLoginNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponseDTO)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetXpHistoryByLoginNotFound from json.
func (s *GetXpHistoryByLoginNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetXpHistoryByLoginNotFound to nil")
	}
	var unwrapped ErrorResponseDTO
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetXpHistoryByLoginNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetXpHistoryByLoginNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetXpHistoryByLoginNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GraphEdgeV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GraphEdgeV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
	{
		e.FieldStart("target")
		e.Str(s.Target)
	}
	{
		e.FieldStart("sourceHandle")
		e.Str(s.SourceHandle)
	}
	{
		e.FieldStart("targetHandle")
		e.Str(s.TargetHandle)
	}
}

var jsonFieldsNameOfGraphEdgeV1DTO = [5]string{
	0: "id",
	1: "source",
	2: "target",
	3: "sourceHandle",
	4: "targetHandle",
}

// Decode decodes GraphEdgeV1DTO from json.
func (s *GraphEdgeV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GraphEdgeV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "source":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "target":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Target = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		case "sourceHandle":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.SourceHandle = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sourceHandle\"")
			}
		case "targetHandle":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.TargetHandle = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetHandle\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GraphEdgeV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGraphEdgeV1DTO) {
					name = jsonFieldsNameOfGraphEdgeV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GraphEdgeV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GraphEdgeV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GraphNodeItemV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GraphNodeItemV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("handles")
		e.ArrStart()
		for _, elem := range s.Handles {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("entityType")
		s.EntityType.Encode(e)
	}
	{
		e.FieldStart("entityId")
		e.Int64(s.EntityId)
	}
}

var jsonFieldsNameOfGraphNodeItemV1DTO = [5]string{
	0: "id",
	1: "code",
	2: "handles",
	3: "entityType",
	4: "entityId",
}

// Decode decodes GraphNodeItemV1DTO from json.
func (s *GraphNodeItemV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GraphNodeItemV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "handles":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Handles = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Handles = append(s.Handles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"handles\"")
			}
		case "entityType":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.EntityType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entityType\"")
			}
		case "entityId":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int64()
				s.EntityId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entityId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GraphNodeItemV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGraphNodeItemV1DTO) {
					name = jsonFieldsNameOfGraphNodeItemV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GraphNodeItemV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GraphNodeItemV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GraphNodeItemV1DTOEntityType as json.
func (s GraphNodeItemV1DTOEntityType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GraphNodeItemV1DTOEntityType from json.
func (s *GraphNodeItemV1DTOEntityType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GraphNodeItemV1DTOEntityType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GraphNodeItemV1DTOEntityType(v) {
	case GraphNodeItemV1DTOEntityTypePROJECT:
		*s = GraphNodeItemV1DTOEntityTypePROJECT
	case GraphNodeItemV1DTOEntityTypeCOURSE:
		*s = GraphNodeItemV1DTOEntityTypeCOURSE
	default:
		*s = GraphNodeItemV1DTOEntityType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GraphNodeItemV1DTOEntityType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GraphNodeItemV1DTOEntityType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GraphNodeV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GraphNodeV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("label")
		e.Str(s.Label)
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGraphNodeV1DTO = [3]string{
	0: "id",
	1: "label",
	2: "items",
}

// Decode decodes GraphNodeV1DTO from json.
func (s *GraphNodeV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GraphNodeV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "label":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Label = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Items = make([]GraphNodeItemV1DTO, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GraphNodeItemV1DTO
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GraphNodeV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGraphNodeV1DTO) {
					name = jsonFieldsNameOfGraphNodeV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GraphNodeV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GraphNodeV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GraphV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GraphV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nodes")
		e.ArrStart()
		for _, elem := range s.Nodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("edges")
		e.ArrStart()
		for _, elem := range s.Edges {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGraphV1DTO = [2]string{
	0: "nodes",
	1: "edges",
}

// Decode decodes GraphV1DTO from json.
func (s *GraphV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GraphV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodes":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Nodes = make([]GraphNodeV1DTO, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GraphNodeV1DTO
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		case "edges":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Edges = make([]GraphEdgeV1DTO, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GraphEdgeV1DTO
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Edges = append(s.Edges, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edges\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GraphV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGraphV1DTO) {
					name = jsonFieldsNameOfGraphV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GraphV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GraphV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConditionRuleGroupV1DTOLogicalOperator as json.
func (o OptConditionRuleGroupV1DTOLogicalOperator) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ConditionRuleGroupV1DTOLogicalOperator from json.
func (o *OptConditionRuleGroupV1DTOLogicalOperator) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConditionRuleGroupV1DTOLogicalOperator to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConditionRuleGroupV1DTOLogicalOperator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConditionRuleGroupV1DTOLogicalOperator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConditionRuleV1DTOLogicalOperator as json.
func (o OptConditionRuleV1DTOLogicalOperator) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ConditionRuleV1DTOLogicalOperator from json.
func (o *OptConditionRuleV1DTOLogicalOperator) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConditionRuleV1DTOLogicalOperator to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConditionRuleV1DTOLogicalOperator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConditionRuleV1DTOLogicalOperator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ParticipantBadgeV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ParticipantBadgeV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("receiptDateTime")
		json.EncodeDateTime(e, s.ReceiptDateTime)
	}
	{
		e.FieldStart("iconUrl")
		e.Str(s.IconUrl)
	}
}

var jsonFieldsNameOfParticipantBadgeV1DTO = [3]string{
	0: "name",
	1: "receiptDateTime",
	2: "iconUrl",
}

// Decode decodes ParticipantBadgeV1DTO from json.
func (s *ParticipantBadgeV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipantBadgeV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "receiptDateTime":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ReceiptDateTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"receiptDateTime\"")
			}
		case "iconUrl":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.IconUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"iconUrl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ParticipantBadgeV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfParticipantBadgeV1DTO) {
					name = jsonFieldsNameOfParticipantBadgeV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ParticipantBadgeV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipantBadgeV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ParticipantBadgesV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ParticipantBadgesV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("badges")
		e.ArrStart()
		for _, elem := range s.Badges {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfParticipantBadgesV1DTO = [1]string{
	0: "badges",
}

// Decode decodes ParticipantBadgesV1DTO from json.
func (s *ParticipantBadgesV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipantBadgesV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "badges":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Badges = make([]ParticipantBadgeV1DTO, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ParticipantBadgeV1DTO
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Badges = append(s.Badges, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"badges\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ParticipantBadgesV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfParticipantBadgesV1DTO) {
					name = jsonFieldsNameOfParticipantBadgesV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ParticipantBadgesV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipantBadgesV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ParticipantCampusV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ParticipantCampusV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("shortName")
		e.Str(s.ShortName)
	}
}

var jsonFieldsNameOfParticipantCampusV1DTO = [2]string{
	0: "id",
	1: "shortName",
}

// Decode decodes ParticipantCampusV1DTO from json.
func (s *ParticipantCampusV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipantCampusV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "shortName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ShortName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ParticipantCampusV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfParticipantCampusV1DTO) {
					name = jsonFieldsNameOfParticipantCampusV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ParticipantCampusV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipantCampusV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ParticipantCoalitionV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ParticipantCoalitionV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("coalitionId")
		e.Int64(s.CoalitionId)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Rank.Set {
			e.FieldStart("rank")
			s.Rank.Encode(e)
		}
	}
}

var jsonFieldsNameOfParticipantCoalitionV1DTO = [3]string{
	0: "coalitionId",
	1: "name",
	2: "rank",
}

// Decode decodes ParticipantCoalitionV1DTO from json.
func (s *ParticipantCoalitionV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipantCoalitionV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "coalitionId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.CoalitionId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"coalitionId\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "rank":
			if err := func() error {
				s.Rank.Reset()
				if err := s.Rank.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rank\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ParticipantCoalitionV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfParticipantCoalitionV1DTO) {
					name = jsonFieldsNameOfParticipantCoalitionV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ParticipantCoalitionV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipantCoalitionV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ParticipantCourseV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ParticipantCourseV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int64(s.ID)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.FinalPercentage.Set {
			e.FieldStart("finalPercentage")
			s.FinalPercentage.Encode(e)
		}
	}
	{
		if s.CompletionDateTime.Set {
			e.FieldStart("completionDateTime")
			s.CompletionDateTime.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfParticipantCourseV1DTO = [5]string{
	0: "id",
	1: "title",
	2: "status",
	3: "finalPercentage",
	4: "completionDateTime",
}

// Decode decodes ParticipantCourseV1DTO from json.
func (s *ParticipantCourseV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipantCourseV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.ID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "finalPercentage":
			if err := func() error {
				s.FinalPercentage.Reset()
				if err := s.FinalPercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finalPercentage\"")
			}
		case "completionDateTime":
			if err := func() error {
				s.CompletionDateTime.Reset()
				if err := s.CompletionDateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completionDateTime\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ParticipantCourseV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfParticipantCourseV1DTO) {
					name = jsonFieldsNameOfParticipantCourseV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ParticipantCourseV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipantCourseV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ParticipantCourseV1DTOStatus as json.
func (s ParticipantCourseV1DTOStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ParticipantCourseV1DTOStatus from json.
func (s *ParticipantCourseV1DTOStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipantCourseV1DTOStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ParticipantCourseV1DTOStatus(v) {
	case ParticipantCourseV1DTOStatusASSIGNED:
		*s = ParticipantCourseV1DTOStatusASSIGNED
	case ParticipantCourseV1DTOStatusREGISTERED:
		*s = ParticipantCourseV1DTOStatusREGISTERED
	case ParticipantCourseV1DTOStatusINPROGRESS:
		*s = ParticipantCourseV1DTOStatusINPROGRESS
	case ParticipantCourseV1DTOStatusACCEPTED:
		*s = ParticipantCourseV1DTOStatusACCEPTED
	case ParticipantCourseV1DTOStatusFAILED:
		*s = ParticipantCourseV1DTOStatusFAILED
	default:
		*s = ParticipantCourseV1DTOStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ParticipantCourseV1DTOStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipantCourseV1DTOStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ParticipantCoursesV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ParticipantCoursesV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("courses")
		e.ArrStart()
		for _, elem := range s.Courses {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfParticipantCoursesV1DTO = [1]string{
	0: "courses",
}

// Decode decodes ParticipantCoursesV1DTO from json.
func (s *ParticipantCoursesV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipantCoursesV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "courses":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Courses = make([]ParticipantCourseV1DTO, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ParticipantCourseV1DTO
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Courses = append(s.Courses, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"courses\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ParticipantCoursesV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfParticipantCoursesV1DTO) {
					name = jsonFieldsNameOfParticipantCoursesV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ParticipantCoursesV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipantCoursesV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ParticipantFeedbackV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ParticipantFeedbackV1DTO) encodeFields(e *jx.Encoder) {
	{
		if s.AverageVerifierPunctuality.Set {
			e.FieldStart("averageVerifierPunctuality")
			s.AverageVerifierPunctuality.Encode(e)
		}
	}
	{
		if s.AverageVerifierInterest.Set {
			e.FieldStart("averageVerifierInterest")
			s.AverageVerifierInterest.Encode(e)
		}
	}
	{
		if s.AverageVerifierThoroughness.Set {
			e.FieldStart("averageVerifierThoroughness")
			s.AverageVerifierThoroughness.Encode(e)
		}
	}
	{
		if s.AverageVerifierFriendliness.Set {
			e.FieldStart("averageVerifierFriendliness")
			s.AverageVerifierFriendliness.Encode(e)
		}
	}
}

var jsonFieldsNameOfParticipantFeedbackV1DTO = [4]string{
	0: "averageVerifierPunctuality",
	1: "averageVerifierInterest",
	2: "averageVerifierThoroughness",
	3: "averageVerifierFriendliness",
}

// Decode decodes ParticipantFeedbackV1DTO from json.
func (s *ParticipantFeedbackV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipantFeedbackV1DTO to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "averageVerifierPunctuality":
			if err := func() error {
				s.AverageVerifierPunctuality.Reset()
				if err := s.AverageVerifierPunctuality.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averageVerifierPunctuality\"")
			}
		case "averageVerifierInterest":
			if err := func() error {
				s.AverageVerifierInterest.Reset()
				if err := s.AverageVerifierInterest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averageVerifierInterest\"")
			}
		case "averageVerifierThoroughness":
			if err := func() error {
				s.AverageVerifierThoroughness.Reset()
				if err := s.AverageVerifierThoroughness.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averageVerifierThoroughness\"")
			}
		case "averageVerifierFriendliness":
			if err := func() error {
				s.AverageVerifierFriendliness.Reset()
				if err := s.AverageVerifierFriendliness.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averageVerifierFriendliness\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ParticipantFeedbackV1DTO")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ParticipantFeedbackV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipantFeedbackV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ParticipantLoginsV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ParticipantLoginsV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("participants")
		e.ArrStart()
		for _, elem := range s.Participants {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfParticipantLoginsV1DTO = [1]string{
	0: "participants",
}

// Decode decodes ParticipantLoginsV1DTO from json.
func (s *ParticipantLoginsV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipantLoginsV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "participants":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Participants = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Participants = append(s.Participants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participants\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ParticipantLoginsV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfParticipantLoginsV1DTO) {
					name = jsonFieldsNameOfParticipantLoginsV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ParticipantLoginsV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipantLoginsV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ParticipantPointsV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ParticipantPointsV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("peerReviewPoints")
		e.Int32(s.PeerReviewPoints)
	}
	{
		e.FieldStart("codeReviewPoints")
		e.Int32(s.CodeReviewPoints)
	}
	{
		e.FieldStart("coins")
		e.Int32(s.Coins)
	}
}

var jsonFieldsNameOfParticipantPointsV1DTO = [3]string{
	0: "peerReviewPoints",
	1: "codeReviewPoints",
	2: "coins",
}

// Decode decodes ParticipantPointsV1DTO from json.
func (s *ParticipantPointsV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipantPointsV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "peerReviewPoints":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.PeerReviewPoints = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"peerReviewPoints\"")
			}
		case "codeReviewPoints":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.CodeReviewPoints = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"codeReviewPoints\"")
			}
		case "coins":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Coins = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"coins\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ParticipantPointsV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfParticipantPointsV1DTO) {
					name = jsonFieldsNameOfParticipantPointsV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ParticipantPointsV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipantPointsV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ParticipantProjectV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ParticipantProjectV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int64(s.ID)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.FinalPercentage.Set {
			e.FieldStart("finalPercentage")
			s.FinalPercentage.Encode(e)
		}
	}
	{
		if s.CompletionDateTime.Set {
			e.FieldStart("completionDateTime")
			s.CompletionDateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.TeamMembers != nil {
			e.FieldStart("teamMembers")
			e.ArrStart()
			for _, elem := range s.TeamMembers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CourseId.Set {
			e.FieldStart("courseId")
			s.CourseId.Encode(e)
		}
	}
}

var jsonFieldsNameOfParticipantProjectV1DTO = [8]string{
	0: "id",
	1: "title",
	2: "type",
	3: "status",
	4: "finalPercentage",
	5: "completionDateTime",
	6: "teamMembers",
	7: "courseId",
}

// Decode decodes ParticipantProjectV1DTO from json.
func (s *ParticipantProjectV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipantProjectV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.ID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "finalPercentage":
			if err := func() error {
				s.FinalPercentage.Reset()
				if err := s.FinalPercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finalPercentage\"")
			}
		case "completionDateTime":
			if err := func() error {
				s.CompletionDateTime.Reset()
				if err := s.CompletionDateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completionDateTime\"")
			}
		case "teamMembers":
			if err := func() error {
				s.TeamMembers = make([]TeamMemberV1DTO, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TeamMemberV1DTO
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TeamMembers = append(s.TeamMembers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamMembers\"")
			}
		case "courseId":
			if err := func() error {
				s.CourseId.Reset()
				if err := s.CourseId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"courseId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ParticipantProjectV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfParticipantProjectV1DTO) {
					name = jsonFieldsNameOfParticipantProjectV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ParticipantProjectV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipantProjectV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ParticipantProjectV1DTOStatus as json.
func (s ParticipantProjectV1DTOStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ParticipantProjectV1DTOStatus from json.
func (s *ParticipantProjectV1DTOStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipantProjectV1DTOStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ParticipantProjectV1DTOStatus(v) {
	case ParticipantProjectV1DTOStatusASSIGNED:
		*s = ParticipantProjectV1DTOStatusASSIGNED
	case ParticipantProjectV1DTOStatusREGISTERED:
		*s = ParticipantProjectV1DTOStatusREGISTERED
	case ParticipantProjectV1DTOStatusINPROGRESS:
		*s = ParticipantProjectV1DTOStatusINPROGRESS
	case ParticipantProjectV1DTOStatusINREVIEWS:
		*s = ParticipantProjectV1DTOStatusINREVIEWS
	case ParticipantProjectV1DTOStatusACCEPTED:
		*s = ParticipantProjectV1DTOStatusACCEPTED
	case ParticipantProjectV1DTOStatusFAILED:
		*s = ParticipantProjectV1DTOStatusFAILED
	default:
		*s = ParticipantProjectV1DTOStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ParticipantProjectV1DTOStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipantProjectV1DTOStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ParticipantProjectV1DTOType as json.
func (s ParticipantProjectV1DTOType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ParticipantProjectV1DTOType from json.
func (s *ParticipantProjectV1DTOType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipantProjectV1DTOType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ParticipantProjectV1DTOType(v) {
	case ParticipantProjectV1DTOTypeINDIVIDUAL:
		*s = ParticipantProjectV1DTOTypeINDIVIDUAL
	case ParticipantProjectV1DTOTypeGROUP:
		*s = ParticipantProjectV1DTOTypeGROUP
	case ParticipantProjectV1DTOTypeEXAM:
		*s = ParticipantProjectV1DTOTypeEXAM
	case ParticipantProjectV1DTOTypeEXAMTEST:
		*s = ParticipantProjectV1DTOTypeEXAMTEST
	default:
		*s = ParticipantProjectV1DTOType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ParticipantProjectV1DTOType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipantProjectV1DTOType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ParticipantProjectsV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ParticipantProjectsV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("projects")
		e.ArrStart()
		for _, elem := range s.Projects {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfParticipantProjectsV1DTO = [1]string{
	0: "projects",
}

// Decode decodes ParticipantProjectsV1DTO from json.
func (s *ParticipantProjectsV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipantProjectsV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "projects":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Projects = make([]ParticipantProjectV1DTO, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ParticipantProjectV1DTO
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Projects = append(s.Projects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projects\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ParticipantProjectsV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfParticipantProjectsV1DTO) {
					name = jsonFieldsNameOfParticipantProjectsV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ParticipantProjectsV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipantProjectsV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ParticipantSkillV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ParticipantSkillV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("points")
		e.Int32(s.Points)
	}
}

var jsonFieldsNameOfParticipantSkillV1DTO = [2]string{
	0: "name",
	1: "points",
}

// Decode decodes ParticipantSkillV1DTO from json.
func (s *ParticipantSkillV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipantSkillV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "points":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Points = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ParticipantSkillV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfParticipantSkillV1DTO) {
					name = jsonFieldsNameOfParticipantSkillV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ParticipantSkillV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipantSkillV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ParticipantSkillsV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ParticipantSkillsV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("skills")
		e.ArrStart()
		for _, elem := range s.Skills {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfParticipantSkillsV1DTO = [1]string{
	0: "skills",
}

// Decode decodes ParticipantSkillsV1DTO from json.
func (s *ParticipantSkillsV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipantSkillsV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "skills":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Skills = make([]ParticipantSkillV1DTO, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ParticipantSkillV1DTO
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Skills = append(s.Skills, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skills\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ParticipantSkillsV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfParticipantSkillsV1DTO) {
					name = jsonFieldsNameOfParticipantSkillsV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ParticipantSkillsV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipantSkillsV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ParticipantV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ParticipantV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("login")
		e.Str(s.Login)
	}
	{
		if s.ClassName.Set {
			e.FieldStart("className")
			s.ClassName.Encode(e)
		}
	}
	{
		if s.ParallelName.Set {
			e.FieldStart("parallelName")
			s.ParallelName.Encode(e)
		}
	}
	{
		e.FieldStart("expValue")
		e.Int64(s.ExpValue)
	}
	{
		e.FieldStart("level")
		e.Int32(s.Level)
	}
	{
		e.FieldStart("expToNextLevel")
		e.Int64(s.ExpToNextLevel)
	}
	{
		e.FieldStart("campus")
		s.Campus.Encode(e)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
}

var jsonFieldsNameOfParticipantV1DTO = [8]string{
	0: "login",
	1: "className",
	2: "parallelName",
	3: "expValue",
	4: "level",
	5: "expToNextLevel",
	6: "campus",
	7: "status",
}

// Decode decodes ParticipantV1DTO from json.
func (s *ParticipantV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipantV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "className":
			if err := func() error {
				s.ClassName.Reset()
				if err := s.ClassName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"className\"")
			}
		case "parallelName":
			if err := func() error {
				s.ParallelName.Reset()
				if err := s.ParallelName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parallelName\"")
			}
		case "expValue":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int64()
				s.ExpValue = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expValue\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.Level = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "expToNextLevel":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int64()
				s.ExpToNextLevel = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expToNextLevel\"")
			}
		case "campus":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Campus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"campus\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ParticipantV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfParticipantV1DTO) {
					name = jsonFieldsNameOfParticipantV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ParticipantV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipantV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ParticipantV1DTOStatus as json.
func (s ParticipantV1DTOStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ParticipantV1DTOStatus from json.
func (s *ParticipantV1DTOStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipantV1DTOStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ParticipantV1DTOStatus(v) {
	case ParticipantV1DTOStatusACTIVE:
		*s = ParticipantV1DTOStatusACTIVE
	case ParticipantV1DTOStatusTEMPORARYBLOCKING:
		*s = ParticipantV1DTOStatusTEMPORARYBLOCKING
	case ParticipantV1DTOStatusEXPELLED:
		*s = ParticipantV1DTOStatusEXPELLED
	case ParticipantV1DTOStatusBLOCKED:
		*s = ParticipantV1DTOStatusBLOCKED
	case ParticipantV1DTOStatusFROZEN:
		*s = ParticipantV1DTOStatusFROZEN
	default:
		*s = ParticipantV1DTOStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ParticipantV1DTOStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipantV1DTOStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ParticipantWorkstationV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ParticipantWorkstationV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("clusterId")
		e.Int64(s.ClusterId)
	}
	{
		e.FieldStart("clusterName")
		e.Str(s.ClusterName)
	}
	{
		e.FieldStart("row")
		e.Str(s.Row)
	}
	{
		e.FieldStart("number")
		e.Int32(s.Number)
	}
}

var jsonFieldsNameOfParticipantWorkstationV1DTO = [4]string{
	0: "clusterId",
	1: "clusterName",
	2: "row",
	3: "number",
}

// Decode decodes ParticipantWorkstationV1DTO from json.
func (s *ParticipantWorkstationV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipantWorkstationV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clusterId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.ClusterId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterId\"")
			}
		case "clusterName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ClusterName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterName\"")
			}
		case "row":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Row = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"row\"")
			}
		case "number":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Number = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ParticipantWorkstationV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfParticipantWorkstationV1DTO) {
					name = jsonFieldsNameOfParticipantWorkstationV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ParticipantWorkstationV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipantWorkstationV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ParticipantXpHistoryItemV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ParticipantXpHistoryItemV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("expValue")
		e.Int64(s.ExpValue)
	}
	{
		e.FieldStart("accrualDateTime")
		json.EncodeDateTime(e, s.AccrualDateTime)
	}
}

var jsonFieldsNameOfParticipantXpHistoryItemV1DTO = [2]string{
	0: "expValue",
	1: "accrualDateTime",
}

// Decode decodes ParticipantXpHistoryItemV1DTO from json.
func (s *ParticipantXpHistoryItemV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipantXpHistoryItemV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "expValue":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.ExpValue = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expValue\"")
			}
		case "accrualDateTime":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.AccrualDateTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accrualDateTime\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ParticipantXpHistoryItemV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfParticipantXpHistoryItemV1DTO) {
					name = jsonFieldsNameOfParticipantXpHistoryItemV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ParticipantXpHistoryItemV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipantXpHistoryItemV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ParticipantXpHistoryV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ParticipantXpHistoryV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("expHistory")
		e.ArrStart()
		for _, elem := range s.ExpHistory {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfParticipantXpHistoryV1DTO = [1]string{
	0: "expHistory",
}

// Decode decodes ParticipantXpHistoryV1DTO from json.
func (s *ParticipantXpHistoryV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipantXpHistoryV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "expHistory":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.ExpHistory = make([]ParticipantXpHistoryItemV1DTO, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ParticipantXpHistoryItemV1DTO
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExpHistory = append(s.ExpHistory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expHistory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ParticipantXpHistoryV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfParticipantXpHistoryV1DTO) {
					name = jsonFieldsNameOfParticipantXpHistoryV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ParticipantXpHistoryV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ParticipantXpHistoryV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("projectId")
		e.Int64(s.ProjectId)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("durationHours")
		e.Int32(s.DurationHours)
	}
	{
		if s.Xp.Set {
			e.FieldStart("xp")
			s.Xp.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.StartConditions != nil {
			e.FieldStart("startConditions")
			e.ArrStart()
			for _, elem := range s.StartConditions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CourseId.Set {
			e.FieldStart("courseId")
			s.CourseId.Encode(e)
		}
	}
}

var jsonFieldsNameOfProjectV1DTO = [8]string{
	0: "projectId",
	1: "title",
	2: "description",
	3: "durationHours",
	4: "xp",
	5: "type",
	6: "startConditions",
	7: "courseId",
}

// Decode decodes ProjectV1DTO from json.
func (s *ProjectV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "projectId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.ProjectId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projectId\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "durationHours":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.DurationHours = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"durationHours\"")
			}
		case "xp":
			if err := func() error {
				s.Xp.Reset()
				if err := s.Xp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "startConditions":
			if err := func() error {
				s.StartConditions = make([]ConditionRuleGroupV1DTO, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConditionRuleGroupV1DTO
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.StartConditions = append(s.StartConditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startConditions\"")
			}
		case "courseId":
			if err := func() error {
				s.CourseId.Reset()
				if err := s.CourseId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"courseId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00101111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectV1DTO) {
					name = jsonFieldsNameOfProjectV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectV1DTOType as json.
func (s ProjectV1DTOType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectV1DTOType from json.
func (s *ProjectV1DTOType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectV1DTOType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectV1DTOType(v) {
	case ProjectV1DTOTypeINDIVIDUAL:
		*s = ProjectV1DTOTypeINDIVIDUAL
	case ProjectV1DTOTypeGROUP:
		*s = ProjectV1DTOTypeGROUP
	case ProjectV1DTOTypeEXAM:
		*s = ProjectV1DTOTypeEXAM
	case ProjectV1DTOTypeEXAMTEST:
		*s = ProjectV1DTOTypeEXAMTEST
	default:
		*s = ProjectV1DTOType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectV1DTOType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectV1DTOType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SaleV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SaleV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.StartDateTime.Set {
			e.FieldStart("startDateTime")
			s.StartDateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ProgressPercentage.Set {
			e.FieldStart("progressPercentage")
			s.ProgressPercentage.Encode(e)
		}
	}
}

var jsonFieldsNameOfSaleV1DTO = [4]string{
	0: "type",
	1: "status",
	2: "startDateTime",
	3: "progressPercentage",
}

// Decode decodes SaleV1DTO from json.
func (s *SaleV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SaleV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "startDateTime":
			if err := func() error {
				s.StartDateTime.Reset()
				if err := s.StartDateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startDateTime\"")
			}
		case "progressPercentage":
			if err := func() error {
				s.ProgressPercentage.Reset()
				if err := s.ProgressPercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progressPercentage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SaleV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSaleV1DTO) {
					name = jsonFieldsNameOfSaleV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SaleV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SaleV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SaleV1DTOStatus as json.
func (s SaleV1DTOStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SaleV1DTOStatus from json.
func (s *SaleV1DTOStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SaleV1DTOStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SaleV1DTOStatus(v) {
	case SaleV1DTOStatusNONACTIVE:
		*s = SaleV1DTOStatusNONACTIVE
	case SaleV1DTOStatusACTIVE:
		*s = SaleV1DTOStatusACTIVE
	case SaleV1DTOStatusPLANNED:
		*s = SaleV1DTOStatusPLANNED
	default:
		*s = SaleV1DTOStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SaleV1DTOStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SaleV1DTOStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SaleV1DTOType as json.
func (s SaleV1DTOType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SaleV1DTOType from json.
func (s *SaleV1DTOType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SaleV1DTOType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SaleV1DTOType(v) {
	case SaleV1DTOTypePRP:
		*s = SaleV1DTOTypePRP
	case SaleV1DTOTypeCRP:
		*s = SaleV1DTOTypeCRP
	default:
		*s = SaleV1DTOType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SaleV1DTOType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SaleV1DTOType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SalesV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SalesV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sales")
		e.ArrStart()
		for _, elem := range s.Sales {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSalesV1DTO = [1]string{
	0: "sales",
}

// Decode decodes SalesV1DTO from json.
func (s *SalesV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SalesV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sales":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Sales = make([]SaleV1DTO, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SaleV1DTO
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Sales = append(s.Sales, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sales\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SalesV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSalesV1DTO) {
					name = jsonFieldsNameOfSalesV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SalesV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SalesV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamMemberV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamMemberV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("login")
		e.Str(s.Login)
	}
	{
		e.FieldStart("isTeamlead")
		e.Bool(s.IsTeamlead)
	}
}

var jsonFieldsNameOfTeamMemberV1DTO = [2]string{
	0: "login",
	1: "isTeamlead",
}

// Decode decodes TeamMemberV1DTO from json.
func (s *TeamMemberV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamMemberV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "isTeamlead":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IsTeamlead = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTeamlead\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamMemberV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamMemberV1DTO) {
					name = jsonFieldsNameOfTeamMemberV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamMemberV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamMemberV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkplaceV1DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkplaceV1DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("row")
		e.Str(s.Row)
	}
	{
		e.FieldStart("number")
		e.Int32(s.Number)
	}
	{
		if s.Login.Set {
			e.FieldStart("login")
			s.Login.Encode(e)
		}
	}
}

var jsonFieldsNameOfWorkplaceV1DTO = [3]string{
	0: "row",
	1: "number",
	2: "login",
}

// Decode decodes WorkplaceV1DTO from json.
func (s *WorkplaceV1DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkplaceV1DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "row":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Row = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"row\"")
			}
		case "number":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Number = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "login":
			if err := func() error {
				s.Login.Reset()
				if err := s.Login.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkplaceV1DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkplaceV1DTO) {
					name = jsonFieldsNameOfWorkplaceV1DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkplaceV1DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkplaceV1DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
